import{Jb as e,bb as s,vb as i,wb as t,xb as n}from"./chunk-7EYVDJ3U.js";var l=class a{static \u0275fac=function(o){return new(o||a)};static \u0275cmp=s({type:a,selectors:[["app-solid-overview"]],decls:79,vars:0,consts:[[1,"mb-4"],[1,"mb-4","mt-2"],[1,"hljs-attr"]],template:function(o,d){o&1&&(i(0,"h1"),e(1,"What's SOLID meaning?"),t(),i(2,"div",0),e(3,` In software engineering, SOLID is a mnemonic acronym for five design principles intended to make software designs more understandable, flexible, and maintainable.\xA0\xA0The principles are a subset of many principles promoted by American software engineer and instructor Robert C. Martin, first introduced in his 2000 paper Design Principles and Design Patterns.
`),t(),i(4,"h2"),e(5,"SOLID Principles"),t(),i(6,"ol")(7,"li")(8,"b"),e(9,"S - Single Responsibility Principle (SRP)"),t(),i(10,"div",1)(11,"h6"),e(12,"Original Definition"),t(),e(13," There should never be more than one reason for a class to change.\xA0\xA0Every class should have only one responsibility."),n(14,"br")(15,"br"),i(16,"h6"),e(17,"Simple Definition"),t(),e(18," SRP means that each class should only be responsible for one thing.\xA0\xA0It keeps classes focused and makes code easier to understand and maintain. "),t()(),i(19,"li")(20,"b"),e(21,"O - Open/Closed Principle (OCP)"),t(),i(22,"div",1)(23,"h6"),e(24,"Original Definition"),t(),e(25," Software entities should be open for extension, but closed for modification."),n(26,"br")(27,"br"),i(28,"h6"),e(29,"Simple Definition"),t(),e(30," he Open/Closed Principle means that once you write a piece of code, you should be able to add new functionality to it without changing the existing code.\xA0\xA0It promotes extending the behavior of software rather than altering it, ensuring that changes don't break existing functionality. "),t()(),i(31,"li")(32,"b"),e(33,"L - Liskov Substitution Principle (LSP)"),t(),i(34,"div",1)(35,"h6"),e(36,"Original Definition"),t(),e(37," If "),i(38,"span",2),e(39,"S"),t(),e(40," is a subtype of "),i(41,"span",2),e(42,"T"),t(),e(43,", then objects of type "),i(44,"span",2),e(45,"T"),t(),e(46," in a program may be replaced with objects of type "),i(47,"span",2),e(48,"S"),t(),e(49," without altering any of the desirable properties of that program."),n(50,"br")(51,"br"),i(52,"h6"),e(53,"Simple Definition"),t(),e(54," The LSP says that if you have a class, you should be able to use any of its subclasses interchangeably without breaking the program. "),t()(),i(55,"li")(56,"b"),e(57,"I - Interface Segregation Principle (ISP)"),t(),i(58,"div",1)(59,"h6"),e(60,"Original Definition"),t(),e(61," No code should be forced to depend on methods it does not use."),n(62,"br")(63,"br"),i(64,"h6"),e(65,"Simple Definition"),t(),e(66,` The ISP means that clients should not be forced to implement methods they don't use.\xA0\xA0It's like saying, "Don't make people take things they don't need." `),t()(),i(67,"li")(68,"b"),e(69,"D - Dependency Inversion Principle (DIP)"),t(),i(70,"div",1)(71,"h6"),e(72,"Original Definition"),t(),e(73," High-level modules should not import anything from low-level modules.\xA0\xA0Both should depend on abstractions. Abstractions should not depend on details.\xA0\xA0Details (concrete implementations) should depend on abstractions."),n(74,"br")(75,"br"),i(76,"h6"),e(77,"Simple Definition"),t(),e(78," DIP means that instead of high-level modules depending directly on low-level modules, both should depend on abstractions.\xA0\xA0This way, changes in low-level modules don't directly affect high-level ones, promoting flexible and maintainable code. "),t()()())},encapsulation:2})};export{l as a};
