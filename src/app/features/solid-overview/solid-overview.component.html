<h1>What's SOLID meaning?</h1>

<div class="mb-4">
  In software engineering, SOLID is a mnemonic acronym for five design
  principles intended to make software designs more understandable, flexible,
  and maintainable.&nbsp;&nbsp;The principles are a subset of many principles
  promoted by American software engineer and instructor Robert C. Martin, first
  introduced in his 2000 paper Design Principles and Design Patterns.
</div>

<h2>SOLID Principles</h2>

<ol>
  <li>
    <b>S - Single Responsibility Principle (SRP)</b>

    <div class="mb-4 mt-2">
      <h6>Original Definition</h6>
      There should never be more than one reason for a class to
      change.&nbsp;&nbsp;Every class should have only one responsibility.<br /><br />

      <h6>Simple Definition</h6>
      SRP means that each class should only be responsible for one
      thing.&nbsp;&nbsp;It keeps classes focused and makes code easier to
      understand and maintain.
    </div>
  </li>
  <li>
    <b>O - Open/Closed Principle (OCP)</b>

    <div class="mb-4 mt-2">
      <h6>Original Definition</h6>
      Software entities should be open for extension, but closed for
      modification.<br /><br />

      <h6>Simple Definition</h6>
      he Open/Closed Principle means that once you write a piece of code, you
      should be able to add new functionality to it without changing the
      existing code.&nbsp;&nbsp;It promotes extending the behavior of software
      rather than altering it, ensuring that changes don't break existing
      functionality.
    </div>
  </li>
  <li>
    <b>L - Liskov Substitution Principle (LSP)</b>

    <div class="mb-4 mt-2">
      <h6>Original Definition</h6>
      If <span class="hljs-attr">S</span> is a subtype of
      <span class="hljs-attr">T</span>, then objects of type
      <span class="hljs-attr">T</span> in a program may be replaced with objects
      of type <span class="hljs-attr">S</span> without altering any of the
      desirable properties of that program.<br /><br />

      <h6>Simple Definition</h6>
      The LSP says that if you have a class, you should be able to use any of
      its subclasses interchangeably without breaking the program.
    </div>
  </li>
  <li>
    <b>I - Interface Segregation Principle (ISP)</b>

    <div class="mb-4 mt-2">
      <h6>Original Definition</h6>
      No code should be forced to depend on methods it does not use.<br /><br />

      <h6>Simple Definition</h6>
      The ISP means that clients should not be forced to implement methods they
      don't use.&nbsp;&nbsp;It's like saying, "Don't make people take things
      they don't need."
    </div>
  </li>
  <li>
    <b>D - Dependency Inversion Principle (DIP)</b>

    <div class="mb-4 mt-2">
      <h6>Original Definition</h6>
      High-level modules should not import anything from low-level
      modules.&nbsp;&nbsp;Both should depend on abstractions. Abstractions
      should not depend on details.&nbsp;&nbsp;Details (concrete
      implementations) should depend on abstractions.<br /><br />

      <h6>Simple Definition</h6>
      DIP means that instead of high-level modules depending directly on
      low-level modules, both should depend on abstractions.&nbsp;&nbsp;This
      way, changes in low-level modules don't directly affect high-level ones,
      promoting flexible and maintainable code.
    </div>
  </li>
</ol>
